# -*- coding: utf-8 -*-
"""
Real Working Telegram Bot for Ø¬Ù…Ø¹ÙŠØ© Ø­ÙØ¸ Ø§Ù„Ù†Ø¹Ù…Ø© (Hail Food Preservation Society)

New in this version:
- /links, /benefit, /theme, /dialect commands
- Intent routing with auto-inserted official links
- Hail (Ø­Ø§ÙŠÙ„) dialect is DEFAULT (users can toggle to ÙØµØ­Ù‰ with /dialect)
- Keeps: rate limiting, backups, health, stats, admin gating
"""
from dotenv import load_dotenv
load_dotenv()
import os
print(f"[DEBUG] BOT_TOKEN loaded: {os.getenv('BOT_TOKEN')}")



import logging
import threading
from datetime import datetime
from typing import Dict

import requests
from telegram import Update
from telegram.ext import (
    ApplicationBuilder, CommandHandler, MessageHandler,
    filters, ContextTypes
)
from bot_utils import detect_intent

from dotenv import load_dotenv
load_dotenv()

# --- Constants & links -------------------------------------------------------
EMPLOYMENT_URL = "https://khaier.us/login.jsf?id=683"          # Ø§Ù„ØªÙˆØ¸ÙŠÙ
VOLUNTEER_URL  = "https://nvg.gov.sa/"                          # Ø§Ù„ØªØ·ÙˆÙ‘Ø¹ Ø§Ù„ÙˆØ·Ù†ÙŠ
BENEFICIARY_SIGNUP_URL = "https://khaier.app/auth/signup/683"   # ØªØ³Ø¬ÙŠÙ„ Ù…Ø³ØªÙÙŠØ¯ Ø¬Ø¯ÙŠØ¯
BENEFICIARY_YT = "https://youtu.be/0zi63JgR_uM"                 # Ø´Ø±Ø­ ÙÙŠØ¯ÙŠÙˆ

BENEFICIARY_REQUIREMENTS_BULLETS = [
    "Ø§Ù„Ù‡ÙˆÙŠØ© Ø§Ù„ÙˆØ·Ù†ÙŠØ© (ØµÙˆØ±Ø© ÙˆØ§Ø¶Ø­Ø© Ù„Ù„ÙˆØ¬Ù‡ÙŠÙ†).",
    "Ù…Ø´Ù‡Ø¯ Ø§Ù„Ø­Ø§Ù„Ø© Ø§Ù„Ù…Ø§Ù„ÙŠØ©.",
    "Ù…Ø´Ù‡Ø¯ Ù…Ù† Ø§Ù„Ø¶Ù…Ø§Ù† Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠ Ø£Ùˆ ØªØ¹Ø±ÙŠÙ Ø¨Ø§Ù„Ø±Ø§ØªØ¨ (ØªÙ‚Ø§Ø¹Ø¯/Ø¹Ù…Ù„/Ø¬Ù‡Ø© Ø£Ø®Ø±Ù‰) Ø¨Ø­ÙŠØ« Ù„Ø§ ÙŠØªØ¬Ø§ÙˆØ² Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø¯Ø®Ù„ 6000 Ø±ÙŠØ§Ù„.",
    "Ø¥Ø«Ø¨Ø§Øª Ø§Ù„Ø³ÙƒÙ† Ø¯Ø§Ø®Ù„ Ù†Ø·Ø§Ù‚ Ø­Ø§Ø¦Ù„ (ØµÙƒ Ù…Ù„ÙƒÙŠØ©/Ø¹Ù‚Ø¯ Ø¥ÙŠØ¬Ø§Ø± Ù…Ù† Ù…Ù†ØµØ© Ø¥ÙŠØ¬Ø§Ø±/Ø®Ø·Ø§Ø¨ Ø¬Ù‡Ø© Ø§Ù„Ø¹Ù…Ù„).",
    "Ø§Ø¬ØªÙŠØ§Ø² Ø§Ù„Ø¨Ø­Ø« Ø§Ù„Ø§Ø¬ØªÙ…Ø§Ø¹ÙŠ ÙˆÙ…ÙˆØ§ÙÙ‚Ø© Ø§Ù„Ù„Ø¬Ù†Ø©.",
    "Ø£Ù† ÙŠÙƒÙˆÙ† Ø§Ù„Ø·Ù„Ø¨ Ø¶Ù…Ù† Ø§Ø®ØªØµØ§Øµ Ø§Ù„Ø¬Ù…Ø¹ÙŠØ© ÙˆØ®Ø¯Ù…Ø§ØªÙ‡Ø§.",
]

# --- Imports from local project (with fallbacks) ------------------------------
try:
    from config import Config
    from utils import data_manager, rate_limiter, groq_client, detect_intent  # if available
    MODULES_AVAILABLE = True
except Exception as e:
    logging.warning("Some modules not available: %s", e)
    MODULES_AVAILABLE = False

# --- Logging -----------------------------------------------------------------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s | %(name)s | %(levelname)s | %(message)s",
)
logger = logging.getLogger("bot")

# --- Per-user preferences (in-memory) ----------------------------------------
# NOTE: For production, persist in your data store (DB/redis).
DEFAULT_HAIL_DIALECT = True  # << Hail dialect is default
user_pref: Dict[int, Dict[str, bool]] = {}  # {user_id: {"hail_dialect": bool}}

def get_use_hail_dialect(user_id: int) -> bool:
    # If user not seen before, return default
    return user_pref.get(user_id, {}).get("hail_dialect", DEFAULT_HAIL_DIALECT)

def toggle_hail_dialect(user_id: int) -> bool:
    cur = get_use_hail_dialect(user_id)
    user_pref.setdefault(user_id, {})["hail_dialect"] = not cur
    return not cur

# --- Small helpers ------------------------------------------------------------
def _wrap(text_fusha: str, text_hail: str, use_hail: bool) -> str:
    """Return text in dialect if enabled, else fusha."""
    return text_hail if use_hail else text_fusha

def mask_token(tok: str) -> str:
    if not tok or tok in ("NOT_SET",):
        return "NOT_SET"
    return tok[:10] + "..." if len(tok) > 13 else tok

def build_beneficiary_requirements_md() -> str:
    bullets = "\n".join(f"â€¢ {item}" for item in BENEFICIARY_REQUIREMENTS_BULLETS)
    return (
        "ğŸ“„ **Ø§Ù„Ø´Ø±ÙˆØ· ÙˆØ§Ù„Ù…Ø³ØªÙ†Ø¯Ø§Øª Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©:**\n"
        f"{bullets}\n\n"
        f"ğŸ¥ Ø´Ø±Ø­ ÙÙŠØ¯ÙŠÙˆ: {BENEFICIARY_YT}"
    )

def detect_intent_simple(text: str) -> str:
    """Lightweight fallback intent detector if utils.detect_intent is not available."""
    t = (text or "").strip().lower()
    # Arabic keywords (basic)
    if any(k in t for k in ["ØªØ¨Ø±Ø¹", "Ø·Ø¹Ø§Ù…", "ÙØ§Ø¦Ø¶"]):
        return "DONATION_FOOD"
    if any(k in t for k in ["Ù…Ø³ØªÙÙŠØ¯", "Ø³Ù„Ø©", "Ù…Ø³Ø§Ø¹Ø¯Ø©", "ØªØ³Ø¬ÙŠÙ„"]):
        return "BENEFICIARY_REQUEST"
    if any(k in t for k in ["ØªØ·ÙˆØ¹", "Ù…ØªØ·ÙˆØ¹"]):
        return "VOLUNTEER_SIGNUP"
    if any(k in t for k in ["ÙˆØ¸ÙŠÙØ©", "ÙˆØ¸Ø§ÙŠÙ", "Ø¹Ù…Ù„", "ØªÙˆØ¸ÙŠÙ"]):
        return "EMPLOYMENT"
    return "OTHER"

# --- Bot ---------------------------------------------------------------------
class TelegramBot:
    def __init__(self):
        self.app = None
        self.is_running = False
        self._lock = threading.Lock()
        self.admin_ids = [123456789]  # TODO: replace with real admin IDs

        if MODULES_AVAILABLE:
            try:
                Config.validate()
                Config.create_directories()
            except Exception as e:
                logger.error("Configuration validation failed: %s", e)

    # --- Commands -------------------------------------------------------------
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        u = update.effective_user
        # Persist default for first-time users (optional but nice)
        user_pref.setdefault(u.id, {}).setdefault("hail_dialect", DEFAULT_HAIL_DIALECT)
        use_hail = get_use_hail_dialect(u.id)
        logger.info("START by @%s (%s), hail=%s", u.username, u.id, use_hail)

        text_fusha = (
            "ğŸ‘‹ Ø£Ù‡Ù„Ø§Ù‹ Ø¨Ùƒ! Ø£Ù†Øª ØªØªØ­Ø¯Ø« Ù…Ø¹ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯ Ø§Ù„Ø±Ø³Ù…ÙŠ **Ù„Ø¬Ù…Ø¹ÙŠØ© Ø­ÙØ¸ Ø§Ù„Ù†Ø¹Ù…Ø© Ø¨Ø­Ø§Ø¦Ù„**.\n\n"
            "Ø§Ù„ÙØ¦Ø§Øª: Ø§Ù„Ù…ØªØ¨Ø±Ø¹ÙˆÙ† Ø¨ÙØ§Ø¦Ø¶ Ø§Ù„Ø·Ø¹Ø§Ù…ØŒ Ø§Ù„Ù…Ø³ØªÙÙŠØ¯ÙˆÙ†ØŒ Ø§Ù„Ù…ØªØ·ÙˆØ¹ÙˆÙ†ØŒ ÙˆØ§Ù„Ø§Ø³ØªÙØ³Ø§Ø±Ø§Øª Ø§Ù„Ø¹Ø§Ù…Ø©.\n"
            "Ø§Ù„Ù†Ø·Ø§Ù‚: Ù…Ø¯ÙŠÙ†Ø© Ø­Ø§Ø¦Ù„ ÙˆØ§Ù„Ù…Ø±Ø§ÙƒØ² Ø§Ù„ØªØ§Ø¨Ø¹Ø© Ù„Ù‡Ø§.\n"
            "â° Ø§Ù„Ø¹Ù…Ù„: Ø§Ù„Ø£Ø­Ø¯â€“Ø§Ù„Ø®Ù…ÙŠØ³ 8:00Øµâ€“9:00Ù…\n"
            "ğŸ“ ØªÙˆØ§ØµÙ„/ÙˆØ§ØªØ³Ø§Ø¨: 0551965445\n\n"
            "Ø§ÙƒØªØ¨ Ø·Ù„Ø¨Ùƒ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ø£ÙˆØ§Ù…Ø±:\n"
            "/help â€” Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£ÙˆØ§Ù…Ø±\n"
            "/links â€” Ø±ÙˆØ§Ø¨Ø· Ø§Ù„ØªÙˆØ¸ÙŠÙ/Ø§Ù„ØªØ·ÙˆØ¹/Ø§Ù„ØªØ³Ø¬ÙŠÙ„\n"
            "/benefit â€” Ø´Ø±ÙˆØ· ÙˆÙ…Ø±ÙÙ‚Ø§Øª ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ù…Ø³ØªÙÙŠØ¯\n"
            "/dialect â€” ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„Ø±Ø¯ÙˆØ¯ Ø¨ÙŠÙ† Ø§Ù„ÙØµØ­Ù‰ ÙˆÙ„Ù‡Ø¬Ø© Ø­Ø§ÙŠÙ„"
        )
        text_hail = (
            "ÙŠØ§Ù‡Ù„Ø§ ÙˆØ§Ù„Ù„Ù‡! Ù…Ø¹Ùƒ Ù…Ø³Ø§Ø¹Ø¯ **Ø¬Ù…Ø¹ÙŠØ© Ø­ÙØ¸ Ø§Ù„Ù†Ø¹Ù…Ø© Ø¨Ø­Ø§ÙŠÙ„** ğŸ‘‹\n\n"
            "Ù†Ø®Ø¯Ù…: Ø§Ù„Ù…ØªØ¨Ø±Ù‘Ø¹ÙŠÙ†ØŒ Ø§Ù„Ù…Ø³ØªÙÙŠØ¯ÙŠÙ†ØŒ Ø§Ù„Ù…ØªØ·ÙˆÙ‘Ø¹ÙŠÙ†ØŒ ÙˆØ£ÙŠ Ø§Ø³ØªÙØ³Ø§Ø±.\n"
            "Ù†Ø·Ø§Ù‚Ù†Ø§: Ø­Ø§ÙŠÙ„ ÙˆØ§Ù„Ù…Ø±Ø§ÙƒØ² Ø§Ù„ØªØ§Ø¨Ø¹Ø©.\n"
            "â° Ø§Ù„Ø¯ÙˆØ§Ù…: Ø§Ù„Ø£Ø­Ø¯â€“Ø§Ù„Ø®Ù…ÙŠØ³ 8:00 Ø§Ù„ØµØ¨Ø­ Ù„Ù€ 9:00 Ø§Ù„Ù„ÙŠÙ„\n"
            "ğŸ“ Ø§Ù„ØªÙˆØ§ØµÙ„/ÙˆØ§ØªØ³Ø§Ø¨: 0551965445\n\n"
            "Ø§ÙƒØªØ¨ ÙˆØ´ ØªØ¨ÙŠ Ø£Ùˆ Ø§Ø³ØªØ®Ø¯Ù… Ù‡Ø§Ù„Ø£ÙˆØ§Ù…Ø±:\n"
            "/help â€” Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø£ÙˆØ§Ù…Ø±\n"
            "/links â€” Ø±ÙˆØ§Ø¨Ø· Ø§Ù„ØªÙˆØ¸ÙŠÙ/Ø§Ù„ØªØ·ÙˆØ¹/Ø§Ù„ØªØ³Ø¬ÙŠÙ„\n"
            "/benefit â€” Ø§Ù„Ø´Ø±ÙˆØ· ÙˆØ§Ù„Ù…Ø±ÙÙ‚Ø§Øª\n"
            "/dialect â€” ØªØ¨Ø¯ÙŠÙ„ Ø¨ÙŠÙ† Ø§Ù„ÙØµØ­Ù‰ ÙˆÙ„Ù‡Ø¬Ø© Ø­Ø§ÙŠÙ„"
        )
        await update.message.reply_text(_wrap(text_fusha, text_hail, use_hail))

    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        u = update.effective_user
        use_hail = get_use_hail_dialect(u.id)

        text_fusha = (
            "ğŸ¤– **Ø§Ù„Ø£ÙˆØ§Ù…Ø± Ø§Ù„Ù…ØªØ§Ø­Ø©:**\n"
            "/start â€” Ø±Ø³Ø§Ù„Ø© ØªØ±Ø­ÙŠØ¨\n"
            "/help â€” Ù‡Ø°Ù‡ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©\n"
            "/links â€” Ø±ÙˆØ§Ø¨Ø· Ù…Ù‡Ù…Ø© (ØªÙˆØ¸ÙŠÙØŒ ØªØ·ÙˆØ¹ØŒ ØªØ³Ø¬ÙŠÙ„ Ù…Ø³ØªÙÙŠØ¯)\n"
            "/benefit â€” Ø§Ù„Ø´Ø±ÙˆØ· ÙˆØ§Ù„Ù…Ø³ØªÙ†Ø¯Ø§Øª Ù„ØªØ³Ø¬ÙŠÙ„ Ù…Ø³ØªÙÙŠØ¯\n"
            "/health â€” ÙØ­Øµ ØµØ­Ø© Ø§Ù„Ø¨ÙˆØª\n"
            "/stats â€” Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª (Ù…Ø´Ø±ÙÙŠÙ†)\n"
            "/backup â€” Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© (Ù…Ø´Ø±ÙÙŠÙ†)\n"
            "/dialect â€” ØªØ¨Ø¯ÙŠÙ„ Ø§Ù„ÙØµØ­Ù‰/Ù„Ù‡Ø¬Ø© Ø­Ø§ÙŠÙ„"
        )
        text_hail = (
            "ğŸ¤– **Ø§Ù„Ø£ÙˆØ§Ù…Ø±:**\n"
            "/start â€” ØªØ±Ø­ÙŠØ¨\n"
            "/help â€” Ù‡Ø°ÙŠ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©\n"
            "/links â€” Ø±ÙˆØ§Ø¨Ø· Ù…Ù‡Ù…Ù‘Ø© (ØªÙˆØ¸ÙŠÙ/ØªØ·ÙˆØ¹/ØªØ³Ø¬ÙŠÙ„)\n"
            "/benefit â€” Ø§Ù„Ø´Ø±ÙˆØ· ÙˆØ§Ù„Ù…Ø±ÙÙ‚Ø§Øª\n"
            "/health â€” ÙØ­Øµ Ø§Ù„Ø¨ÙˆØª\n"
            "/stats â€” Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª (Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ†)\n"
            "/backup â€” Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ© (Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ†)\n"
            "/dialect â€” ÙØµØ­Ù‰/Ø­Ø§ÙŠÙ„"
        )
        await update.message.reply_text(_wrap(text_fusha, text_hail, use_hail))

    async def links_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        u = update.effective_user
        use_hail = get_use_hail_dialect(u.id)
        text_fusha = (
            "ğŸ”— **Ø±ÙˆØ§Ø¨Ø· Ù…Ù‡Ù…Ø©:**\n"
            f"â€¢ Ø§Ù„ØªÙˆØ¸ÙŠÙ: {EMPLOYMENT_URL}\n"
            f"â€¢ Ø§Ù„ØªØ·ÙˆÙ‘Ø¹ Ø§Ù„ÙˆØ·Ù†ÙŠ: {VOLUNTEER_URL}\n"
            f"â€¢ ØªØ³Ø¬ÙŠÙ„ Ù…Ø³ØªÙÙŠØ¯ Ø¬Ø¯ÙŠØ¯: {BENEFICIARY_SIGNUP_URL}\n"
            f"â€¢ Ø´Ø±Ø­ ÙÙŠØ¯ÙŠÙˆ Ù„Ù„Ù…Ø³ØªÙÙŠØ¯: {BENEFICIARY_YT}"
        )
        text_hail = (
            "ğŸ”— **Ø±ÙˆØ§Ø¨Ø· Ù…Ù‡Ù…Ù‘Ø©:**\n"
            f"â€¢ Ø§Ù„ØªÙˆØ¸ÙŠÙ: {EMPLOYMENT_URL}\n"
            f"â€¢ Ø§Ù„ØªØ·ÙˆÙ‘Ø¹: {VOLUNTEER_URL}\n"
            f"â€¢ ØªØ³Ø¬ÙŠÙ„ Ù…Ø³ØªÙÙŠØ¯: {BENEFICIARY_SIGNUP_URL}\n"
            f"â€¢ ÙÙŠØ¯ÙŠÙˆ Ø§Ù„Ø´Ø±Ø­: {BENEFICIARY_YT}"
        )
        await update.message.reply_text(_wrap(text_fusha, text_hail, use_hail), disable_web_page_preview=True)

    async def benefit_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        u = update.effective_user
        use_hail = get_use_hail_dialect(u.id)
        core = build_beneficiary_requirements_md()
        suffix_f = f"\n\nğŸ“ Ù„Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø¢Ù†: {BENEFICIARY_SIGNUP_URL}"
        suffix_h = f"\n\nğŸ“ Ù„Ù„ØªØ³Ø¬ÙŠÙ„ Ø§Ù„Ø­ÙŠÙ†: {BENEFICIARY_SIGNUP_URL}"
        await update.message.reply_text(_wrap(core + suffix_f, core + suffix_h, use_hail), disable_web_page_preview=True)

    async def theme_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        """Re-send the service â€˜themeâ€™ (info block) quickly."""
        await self.start_command(update, context)

    async def dialect_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        u = update.effective_user
        new_state = toggle_hail_dialect(u.id)
        if new_state:
            await update.message.reply_text("âœ… ØªÙ… ØªÙØ¹ÙŠÙ„ **Ù„Ù‡Ø¬Ø© Ø­Ø§ÙŠÙ„** Ù„Ù„Ø±Ø¯ÙˆØ¯. Ø¥Ø°Ø§ ÙˆØ¯Ùƒ ØªØ±Ø¬Ø¹ Ù„Ù„ÙØµØ­Ù‰ Ø£Ø±Ø³Ù„ /dialect")
        else:
            await update.message.reply_text("âœ… ØªÙ… Ø§Ù„Ø±Ø¬ÙˆØ¹ Ø¥Ù„Ù‰ **Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© Ø§Ù„ÙØµØ­Ù‰**. Ù„ØªÙØ¹ÙŠÙ„ Ù„Ù‡Ø¬Ø© Ø­Ø§ÙŠÙ„ Ø£Ø±Ø³Ù„ /dialect")

    async def stats_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        u = update.effective_user
        if u.id not in self.admin_ids:
            await update.message.reply_text("âš ï¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·.")
            return
        if not MODULES_AVAILABLE:
            await update.message.reply_text("âš ï¸ ÙˆØ­Ø¯Ø© Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± Ù…ØªØ§Ø­Ø©.")
            return

        stats = data_manager.get_statistics()
        msg = (
            "ğŸ“Š **Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª**\n\n"
            f"Ø¥Ø¬Ù…Ø§Ù„ÙŠ Ø§Ù„Ø·Ù„Ø¨Ø§Øª: {stats.get('total_requests', 0)}\n"
            f"Ø·Ù„Ø¨Ø§Øª Ø§Ù„ÙŠÙˆÙ…: {stats.get('today_requests', 0)}\n\n"
            "ØªÙˆØ²ÙŠØ¹ Ø§Ù„Ù†ÙˆØ§ÙŠØ§:\n"
        )
        for k, v in (stats.get("intents", {}) or {}).items():
            msg += f"â€¢ {k}: {v}\n"
        msg += f"\nâ° Ø¢Ø®Ø± ØªØ­Ø¯ÙŠØ«: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
        await update.message.reply_text(msg)

    async def backup_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        u = update.effective_user
        if u.id not in self.admin_ids:
            await update.message.reply_text("âš ï¸ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·.")
            return
        if not MODULES_AVAILABLE:
            await update.message.reply_text("âš ï¸ ÙˆØ­Ø¯Ø© Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± Ù…ØªØ§Ø­Ø©.")
            return

        await update.message.reply_text("ğŸ”„ Ø¬Ø§Ø±ÙŠ Ø¥Ù†Ø´Ø§Ø¡ Ù†Ø³Ø®Ø© Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©...")
        path = data_manager.create_backup()
        await update.message.reply_text("âœ… ØªÙ… Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø³Ø®Ø© Ø§Ù„Ø§Ø­ØªÙŠØ§Ø·ÙŠØ©: {}".format(path) if path else "âŒ ÙØ´Ù„ Ø¥Ù†Ø´Ø§Ø¡ Ø§Ù„Ù†Ø³Ø®Ø©.")

    async def health_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        checks = []
        # DB
        try:
            if MODULES_AVAILABLE:
                data_manager.get_statistics()
                checks.append("âœ… Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª")
            else:
                checks.append("âš ï¸ ÙˆØ­Ø¯Ø© Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª ØºÙŠØ± Ù…ØªØ§Ø­Ø©")
        except Exception as e:
            checks.append(f"âŒ Ù‚Ø§Ø¹Ø¯Ø© Ø§Ù„Ø¨ÙŠØ§Ù†Ø§Øª: {e}")

        # Groq
        try:
            if MODULES_AVAILABLE:
                ok = bool(groq_client.ask("ping"))
                checks.append("âœ… Groq API" if ok else "âš ï¸ Groq API: Ù„Ø§ ÙŠÙˆØ¬Ø¯ Ø±Ø¯")
            else:
                checks.append("âš ï¸ ÙˆØ­Ø¯Ø© Groq ØºÙŠØ± Ù…ØªØ§Ø­Ø©")
        except Exception as e:
            checks.append(f"âŒ Groq API: {e}")

        now = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        msg = f"ğŸ¥ **Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª**\n\nâ° ÙˆÙ‚Øª Ø§Ù„Ø³ÙŠØ±ÙØ±: {now}\n" + "\n".join(checks)
        if all(c.startswith("âœ…") for c in checks):
            msg += "\n\nğŸ‰ Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø¨Ø´ÙƒÙ„ Ù…Ù…ØªØ§Ø²"
        elif any(c.startswith("âŒ") for c in checks):
            msg += "\n\nâš ï¸ ØªÙˆØ¬Ø¯ Ù…Ø´Ø§ÙƒÙ„ ØªØªØ·Ù„Ø¨ Ø§Ù†ØªØ¨Ø§Ù‡"
        else:
            msg += "\n\nâ„¹ï¸ ÙŠØ¹Ù…Ù„ Ù…Ø¹ Ø¨Ø¹Ø¶ Ø§Ù„ØªØ­Ø°ÙŠØ±Ø§Øª"
        await update.message.reply_text(msg)

    # --- Messages -------------------------------------------------------------
    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
        user = update.effective_user
        txt = (update.message.text or "").strip()
        if not txt:
            return

        # Rate limit
        if MODULES_AVAILABLE:
            try:
                if not rate_limiter.is_allowed(user.id):
                    await update.message.reply_text("â³ Ø±Ø³Ø§ÙŠÙ„Ùƒ ÙƒØ«ÙŠØ±Ø© ÙˆØ±Ø§ Ø¨Ø¹Ø¶ØŒ Ø®Ù„Ù‘Ù†Ø§ Ù†ÙƒÙ…Ù„ Ø®Ø·ÙˆØ© Ø®Ø·ÙˆØ©â€”Ø¬Ø§ÙˆØ¨ Ø¢Ø®Ø± Ø³Ø¤Ø§Ù„ ÙÙ‚Ø·.")
                    return
            except Exception:
                pass

        # Intent (cleaned: direct try/except)
        try:
            intent = detect_intent(txt)  # if import failed, except below
        except Exception:
            intent = detect_intent_simple(txt)

        use_hail = get_use_hail_dialect(user.id)
        reply = None

        # Route intents with links + prompts
        if intent == "DONATION_FOOD":
            reply = _wrap(
                "ğŸ± Ø´ÙƒØ±Ù‹Ø§ Ù„ØªØ¨Ø±Ø¹Ùƒ! ÙØ¶Ù„Ø§Ù‹ Ø²ÙˆÙ‘Ø¯Ù†Ø§: Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ø¨Ø§Ù„ØªÙØµÙŠÙ„ØŒ Ù†ÙˆØ¹/ÙƒÙ…ÙŠØ© Ø§Ù„Ø·Ø¹Ø§Ù…ØŒ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ Ù„Ù„Ø§Ø³ØªÙ„Ø§Ù…ØŒ ÙˆØ±Ù‚Ù… Ø§Ù„ØªÙˆØ§ØµÙ„.",
                "ğŸ± ØªØ³Ù„Ù‘Ù…! Ø¹Ø·Ù†Ø§: Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø§Ø³ØªÙ„Ø§Ù…ØŒ Ù†ÙˆØ¹/ÙƒÙ…ÙŠØ© Ø§Ù„Ø£ÙƒÙ„ØŒ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ØŒ ÙˆØ±Ù‚Ù…Ùƒ.",
                use_hail
            )
        elif intent == "BENEFICIARY_REQUEST":
            core = _wrap(
                "ğŸ¤ Ø­ÙŠØ§Ùƒ Ø§Ù„Ù„Ù‡ Ù„Ø·Ù„Ø¨ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©. ÙŠØ±Ø¬Ù‰ ØªØ²ÙˆÙŠØ¯Ù†Ø§: Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø«Ù„Ø§Ø«ÙŠØŒ Ø§Ù„Ø­ÙŠ/Ø§Ù„Ù…ÙˆÙ‚Ø¹ØŒ Ø¹Ø¯Ø¯ Ø£ÙØ±Ø§Ø¯ Ø§Ù„Ø£Ø³Ø±Ø©ØŒ Ø§Ù„Ø­Ø§Ù„Ø©/Ø§Ù„Ø¯Ø®Ù„ Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ÙŠØŒ Ø±Ù‚Ù… Ø§Ù„ØªÙˆØ§ØµÙ„.",
                "ğŸ¤ Ù‡Ù„Ø§ ÙˆØ§Ù„Ù„Ù‡ØŒ Ù„Ø·Ù„Ø¨ Ø§Ù„Ù…Ø³Ø§Ø¹Ø¯Ø© Ø¹Ø·Ù†Ø§: Ø§Ù„Ø§Ø³Ù… Ø§Ù„Ø«Ù„Ø§Ø«ÙŠØŒ Ø§Ù„Ø­ÙŠØŒ Ø¹Ø¯Ø¯ Ø£ÙØ±Ø§Ø¯ Ø§Ù„Ø£Ø³Ø±Ø©ØŒ Ø§Ù„Ø­Ø§Ù„Ø©/Ø§Ù„Ø¯Ø®Ù„ Ø§Ù„ØªÙ‚Ø±ÙŠØ¨ÙŠØŒ ÙˆØ±Ù‚Ù…Ùƒ.",
                use_hail
            )
            links = f"\n\nğŸ“Œ Ø§Ù„ØªØ³Ø¬ÙŠÙ„: {BENEFICIARY_SIGNUP_URL}\n" + build_beneficiary_requirements_md()
            reply = core + "\n" + links
        elif intent == "VOLUNTEER_SIGNUP":
            reply = _wrap(
                f"ğŸ™Œ Ù…Ù…ØªÙ†ÙŠÙ† Ù„Ø±ØºØ¨ØªÙƒ Ø¨Ø§Ù„ØªØ·ÙˆØ¹! Ø³Ø¬Ù‘Ù„ Ø¹Ø¨Ø± Ø§Ù„Ù…Ù†ØµØ© Ø§Ù„ÙˆØ·Ù†ÙŠØ©: {VOLUNTEER_URL}\n"
                "ÙˆØ§Ø°ÙƒØ± Ù„Ù†Ø§: Ø§Ù„Ø§Ø³Ù…ØŒ Ø§Ù„Ø¹Ù…Ø±ØŒ Ø§Ù„Ù…Ù‡Ø§Ø±Ø§Øª/Ø§Ù„ØªØ®ØµØµØŒ Ø§Ù„Ø£ÙˆÙ‚Ø§Øª Ø§Ù„Ù…Ù†Ø§Ø³Ø¨Ø©ØŒ Ø±Ù‚Ù… Ø§Ù„ØªÙˆØ§ØµÙ„.",
                f"ğŸ™Œ Ø¨ÙŠÙ‘Ø¶ Ø§Ù„Ù„Ù‡ ÙˆØ¬Ù‡Ùƒ! Ø³Ø¬Ù‘Ù„ Ø¨Ø§Ù„ØªØ·ÙˆØ¹ Ø¹Ø¨Ø±: {VOLUNTEER_URL}\n"
                "ÙˆØ§Ø°ÙƒØ±: Ø§Ø³Ù…ÙƒØŒ Ø¹Ù…Ø±ÙƒØŒ Ù…Ù‡Ø§Ø±Ø§ØªÙƒØŒ ÙˆÙ‚ØªÙƒ Ø§Ù„Ù…Ù†Ø§Ø³Ø¨ØŒ ÙˆØ±Ù‚Ù…Ùƒ.",
                use_hail
            )
        elif intent == "EMPLOYMENT":
            reply = _wrap(
                f"ğŸ’¼ Ù„Ù„ØªÙˆØ¸ÙŠÙ ÙˆØ§Ù„ØªÙ‚Ø¯ÙŠÙ… Ø¹Ù„Ù‰ Ø§Ù„ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ø´Ø§ØºØ±Ø© ÙŠØ±Ø¬Ù‰ Ø§Ù„Ø¯Ø®ÙˆÙ„ Ø¹Ù„Ù‰: {EMPLOYMENT_URL}",
                f"ğŸ’¼ Ù„Ùˆ Ù†Ø§ÙˆÙŠ ØªÙ‚Ø¯Ù‘Ù… Ø¹Ù„Ù‰ ÙˆØ¸ÙŠÙØ©ØŒ Ù‡Ø°Ø§ Ø§Ù„Ø±Ø§Ø¨Ø·: {EMPLOYMENT_URL}",
                use_hail
            )
        else:
            # Fallback to LLM if available; else default hint
            if MODULES_AVAILABLE:
                try:
                    reply = groq_client.ask(txt) or _wrap(
                        "âš ï¸ Ù„Ù… Ø£ÙÙ‡Ù… Ø·Ù„Ø¨Ùƒ ØªÙ…Ø§Ù…Ù‹Ø§. Ù‡Ù„ ØªÙ‚ØµØ¯ ØªØ¨Ø±Ø¹Ù‹Ø§ØŒ Ø·Ù„Ø¨ Ù…Ø³Ø§Ø¹Ø¯Ø©ØŒ Ø£Ùˆ ØªØ·ÙˆØ¹Ù‹Ø§ØŸ Ø§Ø³ØªØ®Ø¯Ù… /help.",
                        "âš ï¸ Ù…Ø§ ÙÙ‡Ù…Øª Ø²ÙŠÙ†.. ØªÙ‚ØµØ¯ ØªØ¨Ø±Ø¹ØŒ Ù…Ø³Ø§Ø¹Ø¯Ø©ØŒ ÙˆÙ„Ø§ ØªØ·ÙˆØ¹ØŸ Ø¬Ø±Ù‘Ø¨ /help.",
                        use_hail
                    )
                except Exception:
                    reply = _wrap(
                        "âš ï¸ Ù„Ù… Ø£ÙÙ‡Ù… Ø·Ù„Ø¨Ùƒ ØªÙ…Ø§Ù…Ù‹Ø§. Ù‡Ù„ ØªÙ‚ØµØ¯ ØªØ¨Ø±Ø¹Ù‹Ø§ØŒ Ø·Ù„Ø¨ Ù…Ø³Ø§Ø¹Ø¯Ø©ØŒ Ø£Ùˆ ØªØ·ÙˆØ¹Ù‹Ø§ØŸ Ø§Ø³ØªØ®Ø¯Ù… /help.",
                        "âš ï¸ Ù…Ø§ ÙÙ‡Ù…Øª Ø²ÙŠÙ†.. ØªØ¨ÙŠ ØªØ¨Ø±Ø¹ØŒ Ù…Ø³Ø§Ø¹Ø¯Ø©ØŒ ÙˆÙ„Ø§ ØªØ·ÙˆØ¹ØŸ Ø¬Ø±Ù‘Ø¨ /help.",
                        use_hail
                    )
            else:
                reply = _wrap(
                    "ğŸ‘‹ Ù…Ø±Ø­Ø¨Ù‹Ø§! Ø§Ù„Ø¨ÙˆØª ÙŠØ¹Ù…Ù„ Ø¨ÙˆØ¶Ø¹ Ù…Ø­Ø¯ÙˆØ¯. Ù„Ù„ØªÙˆØ§ØµÙ„: 0551965445",
                    "ğŸ‘‹ Ø­ÙŠÙ‘Ø§Ùƒ! Ø§Ù„Ø¨ÙˆØª Ø¨ÙˆØ¶Ø¹ Ù…Ø­Ø¯ÙˆØ¯. Ù„Ù„ØªÙˆØ§ØµÙ„: 0551965445",
                    use_hail
                )

        # Save to storage (best-effort)
        if MODULES_AVAILABLE:
            try:
                row = {
                    "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
                    "user_id": user.id,
                    "username": user.username,
                    "first_name": user.first_name,
                    "last_name": user.last_name,
                    "intent": intent,
                    "message": txt,
                    "reply": reply,
                }
                data_manager.save_to_excel(row)
            except Exception as e:
                logger.warning("Saving failed: %s", e)

        await update.message.reply_text(reply, disable_web_page_preview=True)

    async def error_handler(self, update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
        logger.exception("Unhandled error", exc_info=context.error)

    # --- Internal -------------------------------------------------------------
    def close_webhook_sync(self, token: str, drop_pending: bool = True) -> None:
        try:
            url = f"https://api.telegram.org/bot{token}/deleteWebhook"
            data = {"drop_pending_updates": "true" if drop_pending else "false"}
            r = requests.post(url, data=data, timeout=30)
            try:
                payload = r.json()
            except Exception:
                payload = r.text
            logger.info("deleteWebhook -> %s %s", r.status_code, payload)
        except Exception as e:
            logger.warning("Could not delete webhook: %s", e)

    def setup_handlers(self) -> None:
        self.app.add_handler(CommandHandler("start", self.start_command))
        self.app.add_handler(CommandHandler("help", self.help_command))
        self.app.add_handler(CommandHandler("links", self.links_command))
        self.app.add_handler(CommandHandler("benefit", self.benefit_command))
        self.app.add_handler(CommandHandler("theme", self.theme_command))
        self.app.add_handler(CommandHandler("dialect", self.dialect_command))
        self.app.add_handler(CommandHandler("stats", self.stats_command))
        self.app.add_handler(CommandHandler("backup", self.backup_command))
        self.app.add_handler(CommandHandler("health", self.health_command))
        self.app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_message))
        self.app.add_error_handler(self.error_handler)

    # --- Run ------------------------------------------------------------------
    def run(self) -> None:
        try:
            bot_token = getattr(Config, "BOT_TOKEN", "NOT_SET") if MODULES_AVAILABLE else "NOT_SET"
            groq_key  = getattr(Config, "GROQ_API_KEY", "NOT_SET") if MODULES_AVAILABLE else "NOT_SET"

            # Clear error if token missing (friendlier message)
            if not bot_token or bot_token in ("NOT_SET", "your_bot_token_here"):
                raise RuntimeError("BOT_TOKEN is not set. Put it in .env or environment variables.")

            logger.info("Starting bot -> BOT=%s, GROQ=%s", mask_token(bot_token), mask_token(groq_key))

            if bot_token != "NOT_SET":
                self.close_webhook_sync(bot_token, drop_pending=True)

            self.app = ApplicationBuilder().token(bot_token).build()
            self.setup_handlers()

            logger.info("Polling ...")
            self.is_running = True
            self.app.run_polling(drop_pending_updates=True)
        except KeyboardInterrupt:
            logger.info("Stopped by user")
        except Exception as e:
            logger.error("Startup failed: %s", e)
            raise
        finally:
            self.is_running = False


def main():
    bot = TelegramBot()
    bot.run()

if __name__ == "__main__":
    main()
